var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// a type action with generic T for the payload where T has a property: type
import { useEffect, useState } from 'preact/hooks';
export class Store {
    constructor(initialState, restoreData) {
        this.initialState = initialState;
        this.listeners = [];
        this.actionListeners = [];
        this.actions = [];
        this.reducers = {};
        this.timeout = (ms) => new Promise(res => setTimeout(res, ms));
        this.state = (restoreData === null || restoreData === void 0 ? void 0 : restoreData.state) || initialState;
        if (restoreData === null || restoreData === void 0 ? void 0 : restoreData.actions) {
            this.state = initialState;
            this.actions = restoreData.actions;
            for (const action of this.actions) {
                this.state = this.reduce(this.state, action);
            }
        }
    }
    getState() {
        return this.state;
    }
    getActions() {
        return this.actions;
    }
    dispatch(payload) {
        const timestamp = Date.now();
        const payloadWithTimestamp = Object.assign(Object.assign({}, payload), { timestamp });
        this.actions.push(payloadWithTimestamp);
        this.state = this.reduce(this.state, payloadWithTimestamp);
        this.notifyListeners(payloadWithTimestamp);
    }
    reset() {
        this.state = this.initialState;
        this.actions = [];
    }
    restoreState(state, actions) {
        this.state = state;
        this.actions = actions;
    }
    replay(actions, config) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            this.actions = [];
            let previousTimestamp = 0;
            // if config.until is not null or undefined but accept 0
            if ((config === null || config === void 0 ? void 0 : config.until) != null) {
                actions = actions.slice(0, config.until);
            }
            for (const action of actions) {
                // get the delay between the previous action and this action in milliseconds
                let delay = (config === null || config === void 0 ? void 0 : config.animate) === false ? 0 : !previousTimestamp ? 0 : action.timestamp - previousTimestamp;
                if (config === null || config === void 0 ? void 0 : config.speed) {
                    delay /= config.speed;
                }
                yield this.timeout(delay);
                this.actions.push(action);
                this.state = this.reduce(this.state, action);
                this.notifyListeners(action);
                previousTimestamp = action.timestamp;
            }
        });
    }
    subscribe(listener) {
        this.listeners.push(listener);
        // Immediately notify the listener with the current state
        listener(this.state);
    }
    subscribeActions(listener) {
        this.actionListeners.push(listener);
    }
    unsubscribe(listener) {
        const index = this.listeners.indexOf(listener);
        if (index !== -1) {
            this.listeners.splice(index, 1);
        }
    }
    unsubscribeAll() {
        this.listeners = [];
    }
    addReducer(type, reducer) {
        this.reducers[type] = reducer;
    }
    reduce(state, action) {
        const reducer = this.reducers[action.type];
        return reducer ? reducer(state, action.payload) : state;
    }
    notifyListeners(action) {
        for (const listener of this.listeners) {
            listener(this.state);
        }
        for (const listener of this.actionListeners) {
            listener(action);
        }
        console.log('Action:', action);
    }
}
export function useStore(store) {
    const [state, setState] = useState(store.getState());
    useEffect(() => {
        const listener = (newState) => {
            setState(newState);
        };
        store.subscribe(listener);
        return () => {
            store.unsubscribe(listener);
        };
    }, [store]);
    return state;
}
//# sourceMappingURL=index.js.map