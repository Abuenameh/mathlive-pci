export declare type Action<P> = {
    type: string;
    payload: P;
    timestamp?: number;
};
export declare type GenericT<T> = T & {
    type: string;
    timestamp?: number;
};
export declare type Listener<T> = (state: T) => void;
export declare type Reducer<T, P> = (state: T, payload: P) => T;
export interface IStore<T> {
    getState(): T;
    getActions(): Action<unknown>[];
    dispatch<P>(action: Action<P>): void;
    restoreState(state: T, actions: Action<unknown>[]): void;
    replay(actions: Action<unknown>[], config?: {
        speed?: number;
        animate?: boolean;
    }): Promise<void>;
    reset(): void;
    addReducer<P>(type: string, reducer: Reducer<T, P>): void;
    subscribe(listener: Listener<T>): void;
    subscribeActions(listener: Listener<Action<unknown>>): void;
    unsubscribeAll(): void;
    unsubscribe(listener: Listener<T>): void;
}
export declare class Store<T> implements IStore<T> {
    private initialState;
    private state;
    private listeners;
    private actionListeners;
    private actions;
    private reducers;
    constructor(initialState: T, restoreData?: {
        state: T;
        actions: Action<unknown>[];
    });
    getState(): T;
    getActions(): Action<unknown>[];
    dispatch<P>(payload: Action<P>): void;
    reset(): void;
    restoreState(state: T, actions: Action<unknown>[]): void;
    replay(actions: Action<unknown>[], config?: {
        until?: number;
        speed?: number;
        animate?: boolean;
    }): Promise<void>;
    subscribe(listener: Listener<T>): void;
    subscribeActions(listener: Listener<Action<unknown>>): void;
    unsubscribe(listener: Listener<T>): void;
    unsubscribeAll(): void;
    addReducer<P>(type: string, reducer: Reducer<T, P>): void;
    private reduce;
    private notifyListeners;
    private timeout;
}
export declare function useStore<T>(store: IStore<T>): T;
